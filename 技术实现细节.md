# ğŸ”§ æŠ€æœ¯å®ç°ç»†èŠ‚

## é«˜çº§é—ä¼ ç®—æ³•æ ¸å¿ƒç‰¹æ€§

### æ•°å­¦æ¨¡å‹å®ç°

#### 1. RMSEè®¡ç®— (Consistencyæ–¹æ³•)
```go
// è®¡ç®—å‡æ–¹æ ¹è¯¯å·®ä»¥è¯„ä¼°é‡‡æ ·è´¨é‡
func (sp *SampleProblemAdvanced) Consistency(matrix [][]float64) []float64 {
    // è®¡ç®—é‡‡æ ·æ•°æ®çš„ç™¾åˆ†ä½æ•°
    sampleP := calculatePercentiles(matrix)
    
    // ä¸åŸå§‹æ•°æ®ç™¾åˆ†ä½æ•°å¯¹æ¯”
    for i := 0; i < sp.Np; i++ {
        var mseSum float64
        for j := 0; j < sp.NumLabel; j++ {
            var mse float64
            for k := 0; k < len(sp.Ps); k++ {
                diff := sampleP[idx][k] - originP[idx][k]
                mse += diff * diff  // å¹³æ–¹è¯¯å·®
            }
            mse /= float64(len(sp.Ps))
            mseSum += mse
        }
        result[i] = mseSum  // RMSEç»“æœ
    }
}
```

#### 2. 8ç‚¹ç™¾åˆ†ä½æ•°åˆ†æ
```go
Ps: []float64{0, 25, 50, 75, 90, 95, 99, 100}

// è®¡ç®—æ¯ä¸ªç™¾åˆ†ä½æ•°
func calculatePercentile(data []float64, p float64) float64 {
    sorted := bubbleSort(data)
    index := p / 100.0 * float64(len(sorted)-1)
    return interpolate(sorted, index)
}
```

#### 3. MinMaxæ ‡å‡†åŒ–
```go
// æ•°æ®æ ‡å‡†åŒ–å…¬å¼: (value - min) / (max - min + Îµ)
normalized := (value - sp.MinV[labelIdx]) / (sp.MaxV[labelIdx] - sp.MinV[labelIdx] + 1e-7)
```

### é—ä¼ ç®—æ³•å‚æ•°ä¼˜åŒ–

#### ç§ç¾¤é…ç½®
```go
config := eaopt.NewDefaultGAConfig()
config.NPops = 1           // å•ç§ç¾¤
config.PopSize = 20        // ç§ç¾¤å¤§å°
config.NGenerations = 10   // è¿›åŒ–ä»£æ•°
```

#### å˜å¼‚å’Œäº¤å‰ç­–ç•¥
```go
// å˜å¼‚: éšæœºæ”¹å˜åŸºå› 
func (sv *SampleVectorAdvanced) Mutate(rng *rand.Rand) {
    idx := rng.Intn(len(sv.Genes))
    sv.Genes[idx] = rng.Intn(sv.problem.Ub[idx]-sv.problem.Lb[idx]+1) + sv.problem.Lb[idx]
}

// äº¤å‰: å•ç‚¹äº¤å‰
func (sv *SampleVectorAdvanced) Crossover(other eaopt.Genome, rng *rand.Rand) {
    crossPoint := rng.Intn(len(sv.Genes))
    // äº¤æ¢crossPointä¹‹åçš„åŸºå› 
}
```

## ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ™ºèƒ½å›é€€æœºåˆ¶
```go
// 1. å°è¯•ç®€å•é—ä¼ ç®—æ³•
bestSimple, err := optimizerSimple.OptimizeWithSimpleFallback()
if err != nil {
    // 2. è½¬æ¢ä¸ºé«˜çº§é—®é¢˜
    advancedProblem, err := ConvertToSampleProblemAdvanced(problem, combCount)
    if err != nil {
        // 3. æœ€ç»ˆå›é€€åˆ°éšæœºé‡‡æ ·
        return simpleRandomSampling(traces)
    } else {
        // æ‰§è¡Œé«˜çº§é—ä¼ ç®—æ³•
        bestAdvanced, err := optimizerAdvanced.OptimizeWithAdvancedFallback()
    }
}
```

### æ•°æ®æµè½¬æ¢
```go
// è¾“å…¥: (numTrace, numLabel) 
// å¤„ç†: (Np, C, numLabel) -> (Np, numLabel, C) -> (Np * numLabel, C)
// è¾“å‡º: RMSE fitnesså€¼

matrix := make([][]float64, sp.Np*sp.NumLabel)
for i := 0; i < sp.Np; i++ {
    for j := 0; j < sp.NumLabel; j++ {
        matrix[i*sp.NumLabel+j] = make([]float64, sp.C)
        for k := 0; k < sp.C && k < len(sampleData[i]); k++ {
            matrix[i*sp.NumLabel+j][k] = sampleData[i][k][j]
        }
    }
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ç®¡ç†
- é¢„åˆ†é…æ•°ç»„ç©ºé—´
- å¤ç”¨æ•°æ®ç»“æ„
- é¿å…é¢‘ç¹GC

### 2. è®¡ç®—ä¼˜åŒ–
- çŸ©é˜µè½¬ç½®ä¸€æ¬¡æ€§å®Œæˆ
- ç™¾åˆ†ä½æ•°è®¡ç®—ç¼“å­˜
- å¹¶å‘å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆ

### 3. å®¹é”™å¤„ç†
```go
// æ¯ä¸ªå…³é”®æ­¥éª¤éƒ½æœ‰é”™è¯¯å¤„ç†
if len(ga.HallOfFame) == 0 {
    return nil, fmt.Errorf("no individuals in hall of fame")
}

// ç±»å‹å®‰å…¨æ£€æŸ¥
bestGenome, ok := bestIndividual.Genome.(*SampleVectorAdvanced)
if !ok {
    return nil, fmt.Errorf("unexpected genome type: %T", bestIndividual.Genome)
}
```

## ç›‘æ§å’Œè°ƒè¯•

### æ—¥å¿—çº§åˆ«è®¾è®¡
```yaml
service:
  telemetry:
    logs:
      level: debug  # è¯¦ç»†è°ƒè¯•ä¿¡æ¯
```

### å…³é”®æŒ‡æ ‡ç›‘æ§
- `input_traces`: è¾“å…¥traceæ•°é‡
- `output_traces`: è¾“å‡ºtraceæ•°é‡  
- `actual_sampling_rate`: å®é™…é‡‡æ ·ç‡
- `buffer_size`: ç¼“å†²åŒºä½¿ç”¨æƒ…å†µ

### è°ƒè¯•è¾“å‡ºç¤ºä¾‹
```
[DEBUG] Starting advanced genetic algorithm optimization...
[DEBUG] Creating advanced GA with config: NPops=1, PopSize=20, NGenerations=10
[DEBUG] Running advanced GA minimize...
[DEBUG] Successfully optimized with 5 genes, fitness: 0.123456
âœ… Tail sampling completed {"input_traces": 5, "output_traces": 5, "actual_sampling_rate": 100}
```

## æ‰©å±•æ¥å£

### æ–°ç®—æ³•é›†æˆ
```go
// 1. å®ç°Genomeæ¥å£
type NewAlgorithmVector struct {
    // ç®—æ³•ç‰¹å®šæ•°æ®
}

func (nav *NewAlgorithmVector) Evaluate() (float64, error) {
    // é€‚åº”åº¦å‡½æ•°å®ç°
}

// 2. æ·»åŠ åˆ°å›é€€é“¾
if simpleErr != nil {
    if advancedErr != nil {
        // å°è¯•æ–°ç®—æ³•
        newResult, err := newAlgorithmOptimizer.Optimize()
    }
}
```

### é…ç½®å‚æ•°æ‰©å±•
```yaml
tail_sampling:
  algorithm_config:
    simple:
      generations: 5
    advanced:
      generations: 10
      population_size: 20
    custom:
      # è‡ªå®šä¹‰ç®—æ³•å‚æ•°
```

è¿™å¥—ç³»ç»Ÿå±•ç¤ºäº†å¦‚ä½•å°†å¤æ‚çš„æœºå™¨å­¦ä¹ ç®—æ³•é›†æˆåˆ°ç”Ÿäº§çº§çš„å¾®æœåŠ¡ç›‘æ§ç³»ç»Ÿä¸­ï¼ŒåŒæ—¶ä¿æŒé«˜æ€§èƒ½ã€é«˜å¯é æ€§å’Œè‰¯å¥½çš„å¯æ‰©å±•æ€§ã€‚
